import sys
input = sys.stdin.readline  # 한 줄에 여러 입력 받을 때 사용

MOD = 10007 # 모듈 계산을 위해 값 저장

"""
 dp[i][j] = 수의 길이가 i이고, 일의 자리 수가 j인 오르막 수의 개수

 -> (j보다 작은 수 or j와 같은 수) + j를 하면 오르막 수가 됨
 -> j보다 작은 수로 끝나는 길이 i - 1 인 오르막 수 개수 + j로 끝나는 길이 i - 1 인 오르막 수 개수
 -> j보다 작은 수로 끝나고 길이가 i - 1 인 오르막 수의 접근은 길이 i인 오르막 수에서 마지막 수를 j로 대체하는 것으로 해결 가능
 => dp[i][j] = dp[i][j - 1] + dp[i - 1][j]

 dp 배열 채운 후, 길이가 n이고 일의 자리 수가 0 ~ 9인 오르막 수 개수 모두 더하면 됨!

 ex. 길이가 2인 오르막 수의 개수를 구해야 한다면
      0  1  2  3  4  5  6  7  8  9
  -------------------------------
  1 : 1  1  1  1  1  1  1  1  1  1
  2 : 1  2  3  4  5  6  7  8  9  10
  -> 2행의 값을 모두 더해서 출력!

  해당 풀이는 연산 편하게 하기 위해 미리 dp 값 1로 초기화
  !주의! 마지막에 길이 n인 오르막 수 모두 더할 때도 모듈러 연산 해야함
"""

def count_inc_num(n):                   # 오르막 수 개수 구하는 함수
    dp = [[1]*10 for _ in range(n+1)]   # 초기값으로 0에서 9까지 1로 채운 2차원 배열 할당-> dp[ N의 수 ][ N 자리 숫자일 때 해당 숫자 앞에 올 수 있는 일의 자리 수 ]
    for length in range(2, n+1):        # 자리 수마다 계산
        for digit in range(1, 10):      # 뒤에 있는 숫자
            dp[length][digit] %= MOD    #MOD로 나눈 나머지로 갱신
            dp[length][digit] = dp[length][digit - 1] + dp[length - 1][digit]   # 뒤에 오는 숫자를 기준으로 앞에 올 숫자의 경우의 수 계산
    return sum(dp[n]) % MOD             # MOD로 나눈 나머지 반환


n = int(input())                        # 정수 입력 값 저장
print(count_inc_num(n))                 # 계산한 값 출력